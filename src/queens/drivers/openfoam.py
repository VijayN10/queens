"""Driver to run OpenFOAM simulations."""

import re
from pathlib import Path

from queens.drivers.jobscript import Jobscript
from queens.utils.logger_settings import log_init_args

_JOBSCRIPT_TEMPLATE_CONTAINER = """
#!/bin/bash
# OpenFOAM container execution script generated by QUEENS

cd "{{ case_dir }}"

{{ container_command }} -- bash -c "
    source {{ openfoam_bashrc }}
    
    if [ -f 'system/blockMeshDict' ]; then
        echo 'Generating mesh...'
        blockMesh
    fi
    
    if {{ check_mesh }}; then
        echo 'Checking mesh...'
        checkMesh
    fi
    
    {% if parallel and num_procs > 1 %}
    if [ -f 'system/decomposeParDict' ]; then
        decomposePar
    fi
    mpirun -np {{ num_procs }} {{ solver }} -parallel > {{ log_file }} 2>&1
    if [ -f 'system/decomposeParDict' ]; then
        reconstructPar
    fi
    {% else %}
    {{ solver }} > {{ log_file }} 2>&1
    {% endif %}
    
    echo 'OpenFOAM simulation completed!'
"
"""

_JOBSCRIPT_TEMPLATE_NATIVE = """
#!/bin/bash
# OpenFOAM native execution script generated by QUEENS

source {{ openfoam_bashrc }}
cd "{{ case_dir }}"

if [ -f "system/blockMeshDict" ]; then
    echo "Generating mesh..."
    blockMesh
fi

if {{ check_mesh }}; then
    echo "Checking mesh..."
    checkMesh
fi

{% if parallel and num_procs > 1 %}
if [ -f "system/decomposeParDict" ]; then
    decomposePar
fi
mpirun -np {{ num_procs }} {{ solver }} -parallel > {{ log_file }} 2>&1
if [ -f "system/decomposeParDict" ]; then
    reconstructPar
fi
{% else %}
{{ solver }} > {{ log_file }} 2>&1
{% endif %}

echo "OpenFOAM simulation completed!"
"""


class OpenFoam(Jobscript):
    """Driver to run OpenFOAM simulations."""

    @log_init_args
    def __init__(
        self,
        parameters,
        case_template_dir,
        solver="simpleFoam",
        parallel=False,
        num_procs=1,
        container_command=None,
        openfoam_bashrc="/opt/openfoam9/etc/bashrc",
        check_mesh=True,
        files_to_copy=None,
        data_processor=None,
        gradient_data_processor=None,
    ):
        """Initialize OpenFoam driver.

        Args:
            parameters (Parameters): Parameters object for UQ study
            case_template_dir (str, Path): Path to OpenFOAM case template directory
            solver (str): OpenFOAM solver name (default: simpleFoam)
            parallel (bool): Run simulation in parallel (default: False)
            num_procs (int): Number of processors for parallel execution
            container_command (str, optional): Container command for execution
            openfoam_bashrc (str): Path to OpenFOAM bashrc file
            check_mesh (bool): Run checkMesh before solving
            files_to_copy (list, optional): Additional files to copy to case directory
            data_processor (obj, optional): Data processor for results extraction
            gradient_data_processor (obj, optional): Data processor for gradient data
        """
        # Select template based on execution mode
        if container_command:
            jobscript_template = _JOBSCRIPT_TEMPLATE_CONTAINER
        else:
            jobscript_template = _JOBSCRIPT_TEMPLATE_NATIVE

        # Set up input templates from case template directory
        input_templates = self._setup_input_templates(case_template_dir)


        # Configure extra options for template rendering
        extra_options = {
            "solver": solver,
            "parallel": parallel,
            "num_procs": num_procs,
            "container_command": container_command or "",
            "openfoam_bashrc": openfoam_bashrc,
            "check_mesh": "true" if check_mesh else "false",
            "log_file": f"log.{solver}",
            "case_dir": ".",
        }

        # Set up files to copy
        if files_to_copy is None:
            files_to_copy = []
        
        case_template_path = Path(case_template_dir)
        if case_template_path.exists():
            files_to_copy.append(str(case_template_path))

        super().__init__(
            parameters=parameters,
            input_templates=input_templates,
            jobscript_template=jobscript_template,
            executable=solver,
            files_to_copy=files_to_copy,
            data_processor=data_processor,
            gradient_data_processor=gradient_data_processor,
            extra_options=extra_options,
        )

    def _setup_input_templates(self, case_template_dir):
        """Set up input templates from case template directory."""
        case_path = Path(case_template_dir)
        input_templates = {}
        
        if not case_path.exists():
            raise FileNotFoundError(f"Case template directory not found: {case_template_dir}")
        
        # Find all .template files recursively
        template_files = list(case_path.rglob("*.template"))
        
        for template_file in template_files:
            relative_path = template_file.relative_to(case_path)
            template_key = str(relative_path).replace("/", "_").replace("\\", "_")
            input_templates[template_key] = str(template_file)
        
        return input_templates


class OpenFoamLogProcessor:
    """Data processor to extract results from OpenFOAM log files."""
    
    def __init__(self, log_file_pattern="log.*"):
        self.log_file_pattern = log_file_pattern
    
    def __call__(self, job_options):
        """Process OpenFOAM simulation results."""
        results = {}
        output_dir = Path(job_options.output_dir)
        
        # Find log files
        log_files = list(output_dir.glob(self.log_file_pattern))
        if not log_files:
            case_dir = output_dir.parent
            log_files = list(case_dir.glob(self.log_file_pattern))
        
        if log_files:
            log_file = log_files[0]
            
            with open(log_file, 'r') as f:
                content = f.read()
            
            results['residuals'] = self._extract_residuals(content)
            results['converged'] = 'End' in content or 'SIMPLE solution converged' in content
            
            # Extract execution time
            time_match = re.search(r'ExecutionTime = ([\d.]+) s', content)
            if time_match:
                results['execution_time'] = float(time_match.group(1))
        
        return results
    
    def _extract_residuals(self, content):
        """Extract residual data from log content."""
        residuals = {}
        
        residual_patterns = {
            'p': r'Solving for p, Initial residual = ([\d.e-]+)',
            'Ux': r'Solving for Ux, Initial residual = ([\d.e-]+)',
            'Uy': r'Solving for Uy, Initial residual = ([\d.e-]+)',
            'Uz': r'Solving for Uz, Initial residual = ([\d.e-]+)',
        }
        
        for field, pattern in residual_patterns.items():
            matches = re.findall(pattern, content)
            if matches:
                residuals[field] = [float(m) for m in matches]
                residuals[f'{field}_final'] = float(matches[-1])
        
        return residuals